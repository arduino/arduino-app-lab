/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
  '/v1/apps': {
    /**
     * Get a list of installed apps/examples
     * @description Returns a list of all apps, and example present. It is also possible to apply different filters.
     */
    get: operations['getApps'];
    /**
     * Creates a new app
     * @description Creates a new app in the default app location.
     */
    post: operations['createApp'];
  };
  [path: `/v1/apps/${string}/bricks`]: {
    /**
     * Get brick instances for an app
     * @description Get the list of brick instances for a specific app.
     */
    get: operations['getAppBrickInstances'];
  };
  [path: `/v1/apps/${string}/bricks/${string}`]: {
    /**
     * Get a specific brick instance by ID
     * @description Get a specific brick instance for an app by its ID.
     */
    get: operations['getAppBrickInstanceByBrickID'];
    /**
     * Upsert a brick instance for an app
     * @description Upsert a brick instance for an app. If the instance does not exist, it will be created. If it exists, it will be updated.
     */
    put: operations['upsertAppBrickInstance'];
    /**
     * Delete a brick instance for an app
     * @description Delete a brick instance for an app. It will remove the brick instance from the app.
     */
    delete: operations['deleteAppBrickInstance'];
    /**
     * Update a brick instance for an app
     * @description Update a brick instance for an app. It update/add only the provided fields.
     */
    patch: operations['updateAppBrickInstance'];
  };
  [path: `/v1/apps/${string}/exposed-ports`]: {
    /**
     * Get app exposed ports
     * @description Return all ports exposed by the given app.
     */
    get: operations['getAppPorts'];
  };
  [path: `/v1/apps/${string}/sketch/libraries/`]: {
    /**
     * Lists the libraries used in the App' sketch.
     * @description Lists the libraries used in the App' sketch.
     */
    get: operations['appSketchListLibraries'];
  };
  [path: `/v1/apps/${string}/sketch/libraries/${string}`]: {
    /**
     * Adds a library to the App' sketch.
     * @description Adds a library to the App' sketch. The library will be added to the sketch project file. The dependencies of the library may be optionally added as well.
     */
    put: operations['appSketchAddLibrary'];
    /**
     * Removes a library from the App' sketch.
     * @description Removes a library from the App' sketch. The library will be removed from the sketch project file.
     */
    delete: operations['appSketchRemoveLibrary'];
  };
  [path: `/v1/apps/${string}`]: {
    /**
     * Get app/example detail
     * @description Return all the detail for the given app
     */
    get: operations['getAppDetails'];
    /**
     * delete the app
     * @description Remove the given app and all the resources it created
     */
    delete: operations['deleteApp'];
    /**
     * Update App Details
     * @description Edit the given application. Is it possible to modify the default status, to add/remove/update bricks and bricks variables.
     */
    patch: operations['editApp'];
  };
  [path: `/v1/apps/${string}/clone`]: {
    /**
     * Creates a new app, from another app or example identified by ID.
     * @description Clone an existing app or example, in a new one. It is possible to specify the new name and icon.
     */
    post: operations['cloneApp'];
  };
  [path: `/v1/apps/${string}/events`]: {
    /**
     * Get application events
     * @description Returns events for a specific app
     */
    get: operations['getAppEvents'];
  };
  [path: `/v1/apps/${string}/logs`]: {
    /**
     * Get the logs of a running app
     * @description Obtain a ServerSentEvnt stream of logs. It is possible to apply different filters.
     */
    get: operations['getAppLogs'];
  };
  [path: `/v1/apps/${string}/start`]: {
    /**
     * Start an existing app/example
     * @description Start the application and handles all the operation to start any dependecies. If the app contains a sketch it also flash it in the micro.
     */
    post: operations['startApp'];
  };
  [path: `/v1/apps/${string}/stop`]: {
    /**
     * Stop an existing app/example
     * @description Stop the application and all it's dependecies. If the app contains a sketch it also remove it from the micro.
     */
    post: operations['stopApp'];
  };
  '/v1/apps/events': {
    /**
     * Get application events
     * @description A stream of Server-Sent Events (SSE) that notifies the apps status.
     * The client will receive events formatted as follows:
     *
     * **Event 'app'**:
     * Contains a JSON object with an informational message.
     * 'event: app'
     * 'data: {"id":"dXNlcjpleGFtcG","name":"example-app-for-status-events","description":"My app description","icon":"ðŸ’»","status":"running","example":false,"default":false}'
     *
     * **Event 'error'**:
     * Contains a JSON object with the details of an error.
     * 'event: error'
     * 'data: {"code":"INTERNAL_SERVER_ERROR","message":"An error occurred during operation"}'
     */
    get: operations['getAppsEvents'];
  };
  '/v1/bricks': {
    /**
     * Get a list of available bricks
     * @description Returns all the existing bricks. Bricks that are ready to use are marked as installed.
     */
    get: operations['getBricks'];
  };
  [path: `/v1/bricks/${string}`]: {
    /**
     * Detail of a brick
     * @description Returns a detailed list of property associated to the given brick.
     */
    get: operations['getBrickDetails'];
  };
  '/v1/config': {
    /**
     * returns application configuration
     * @description returns information about current directory configuration used by the app
     */
    get: operations['getConfig'];
  };
  '/v1/libraries': {
    /**
     * Search Arduino libraries
     * @description Search for Arduino libraries in the registry with various filters.
     */
    get: operations['listLibraries'];
  };
  '/v1/models': {
    /**
     * Get a list of available AI models
     * @description Returns the list of AI models available in the system. It is possible to filter the models by bricks.
     */
    get: operations['getAIModels'];
  };
  [path: `/v1/models/${string}`]: {
    /**
     * Get AI model details
     * @description Returns the details of a specific AI model.
     */
    get: operations['getAIModelDetails'];
  };
  '/v1/properties': {
    /**
     * Get system properties
     * @description Return the list of system properties.
     */
    get: operations['GetPropertyKeys'];
  };
  [path: `/v1/properties/${string}`]: {
    /**
     * Get property by key
     * @description Return a single property by the provided key.
     */
    get: operations['GetProperty'];
    /**
     * Upsert property
     * @description Update or create a new property.
     */
    put: operations['UpdateProperty'];
    /**
     * Delete property by key
     * @description Delete the property by the provided key.
     */
    delete: operations['DeleteProperty'];
  };
  '/v1/system/resources': {
    /**
     * Get system resources usage
     * @description Returns the system resources usage, such as memory, disk and CPU.
     */
    get: operations['getSystemResources'];
  };
  '/v1/system/update/apply': {
    /**
     * Start the upgrade process in background
     * @description Start the upgrade process.
     */
    put: operations['applyUpdate'];
  };
  '/v1/system/update/check': {
    /**
     * Get the packages that requires an upgrade
     * @description Returns the details of packages to be upgraded.
     */
    get: operations['checkUpdate'];
  };
  '/v1/system/update/events': {
    /**
     * SSE stream of the update process
     * @description Returns the events of current update process.
     */
    get: operations['eventsUpdate'];
  };
  '/v1/version': {
    /**
     * application version
     * @description returns the application current version
     */
    get: operations['getVersions'];
  };
}

export type webhooks = Record<string, never>;

export interface components {
  schemas: {
    AIModel: {
      description?: string;
      id?: string;
      name?: string;
    };
    AIModelItem: {
      brick_ids?: string[] | null;
      description?: string;
      id?: string;
      metadata?: {
        [key: string]: string;
      };
      model_configuration?: {
        [key: string]: string;
      };
      name?: string;
      runner?: string;
    };
    AIModelsListResult: {
      models?: components['schemas']['AIModelItem'][] | null;
    };
    AppBrickInstancesResult: {
      bricks?: components['schemas']['BrickInstanceListItem'][] | null;
    };
    AppDetailedBrick: {
      category?: string;
      id: string;
      name: string;
      require_model?: boolean;
    };
    AppDetailedInfo: {
      bricks?: components['schemas']['AppDetailedBrick'][];
      default?: boolean;
      description?: string;
      example?: boolean;
      icon?: string;
      id: string;
      name: string;
      path?: string;
      status: components['schemas']['Status'];
    };
    AppInfo: {
      default?: boolean;
      description?: string;
      example?: boolean;
      icon?: string;
      id?: string;
      name?: string;
      status?: components['schemas']['Status'];
    };
    AppListResponse: {
      /** @description List of applications */
      apps?: components['schemas']['AppInfo'][] | null;
      /** @description List of applications that are broken and couldn't be parsed */
      broken_apps?: components['schemas']['BrokenAppInfo'][];
    };
    AppPortResponse: {
      /**
       * @description exposed port of the app
       * @example 80
       */
      ports?: components['schemas']['Port'][] | null;
    };
    AppReference: {
      icon?: string;
      id?: string;
      name?: string;
    };
    BrickConfigVariable: {
      description?: string;
      name?: string;
      required?: boolean;
      value?: string;
    };
    BrickCreateUpdateRequest: {
      model?: string | null;
      variables?: {
        [key: string]: string;
      };
    };
    BrickDetailsResult: {
      api_docs_path?: string;
      author?: string;
      category?: string;
      code_examples?: components['schemas']['CodeExample'][] | null;
      compatible_models?: components['schemas']['AIModel'][] | null;
      config_variables?: components['schemas']['BrickConfigVariable'][] | null;
      description?: string;
      id?: string;
      name?: string;
      readme?: string;
      require_model?: boolean;
      status?: string;
      used_by_apps?: components['schemas']['AppReference'][] | null;
      /** @description Deprecated: use config_variables instead. This field is kept for backward compatibility. */
      variables?: {
        [key: string]: components['schemas']['BrickVariable'];
      } | null;
    };
    BrickInstance: {
      author?: string;
      category?: string;
      compatible_models?: components['schemas']['AIModel'][] | null;
      config_variables?: components['schemas']['BrickConfigVariable'][];
      id?: string;
      model?: string;
      name?: string;
      require_model?: boolean;
      status?: string;
      /** @description Deprecated: use config_variables instead. This field is kept for backward compatibility. */
      variables?: {
        [key: string]: string;
      };
    };
    BrickInstanceListItem: {
      author?: string;
      category?: string;
      config_variables?: components['schemas']['BrickConfigVariable'][];
      id?: string;
      model?: string;
      name?: string;
      require_model?: boolean;
      status?: string;
      /** @description Deprecated: use config_variables instead. This field is kept for backward compatibility. */
      variables?: {
        [key: string]: string;
      };
    };
    BrickListItem: {
      author?: string;
      category?: string;
      description?: string;
      id?: string;
      name?: string;
      require_model?: boolean;
      status?: string;
    };
    BrickListResult: {
      bricks?: components['schemas']['BrickListItem'][] | null;
    };
    BrickVariable: {
      default_value?: string;
      description?: string;
      required?: boolean;
    };
    BrokenAppInfo: {
      error?: string;
      name?: string;
    };
    CloneAppResponse: {
      id?: string;
    };
    CloneRequest: {
      /** @description application icon */
      icon?: string | null;
      /**
       * @description application name
       * @example My Awesome App
       */
      name?: string | null;
    };
    CodeExample: {
      path?: string;
    };
    ConfigDirectories: {
      apps?: string;
      data?: string;
      examples?: string;
    };
    ConfigResponse: {
      directories?: components['schemas']['ConfigDirectories'];
    };
    CreateAppRequest: {
      /** @description application description */
      description?: string;
      /** @description application icon */
      icon?: string;
      /**
       * @description application name
       * @example My Awesome App
       */
      name: string;
    };
    CreateAppResponse: {
      id?: string;
    };
    EditRequest: {
      default?: boolean | null;
      /**
       * @description application description
       * @example This is my awesome app
       */
      description?: string | null;
      /**
       * @description application icon
       * @example ðŸ’»
       */
      icon?: string | null;
      /**
       * @description application name
       * @example My Awesome App
       */
      name?: string | null;
    };
    ErrorResponse: {
      code?: number;
      message?: string;
    };
    Library: {
      architectures?: string[] | null;
      author?: string;
      category?: string;
      dependencies?:
        | {
            name?: string;
          }[]
        | null;
      example_count?: number;
      id?: string;
      includes?: string[] | null;
      license?: string;
      maintainer?: string;
      name?: string;
      paragraph?: string;
      platform?: string | null;
      releases?:
        | {
            id?: string;
            version?: string;
          }[]
        | null;
      repository?: {
        forks?: number;
        stars?: number;
        updated_at?: string;
        url?: string;
      } | null;
      sentence?: string;
      types?: string[] | null;
      website?: string;
    };
    LibraryListResponse: {
      libraries?: components['schemas']['Library'][] | null;
      pagination?: components['schemas']['Pagination'];
    };
    LibraryReleaseID: Record<string, never>;
    /**
     * @description Package type
     * @enum {string}
     */
    PackageType: 'arduino-platform' | 'debian-package';
    Pagination: {
      next_page?: number;
      page?: number;
      per_page?: number;
      prev_page?: number;
      total_items?: number;
      total_pages?: number;
    };
    Port: {
      /**
       * @description exposed port	of the app
       * @example 80
       */
      port?: string;
      /**
       * @description name of the service if the port is exposed by a brick
       * @example Web Interface
       */
      serviceName?: string;
      /**
       * @description source of the port, e.g. app or brick:data-storage
       * @example brick:data-storage
       */
      source?: string;
    };
    PropertyKeysResponse: {
      keys?: string[] | null;
    };
    SketchAddLibraryResponse: {
      libraries?: components['schemas']['LibraryReleaseID'][] | null;
    };
    SketchListLibraryResponse: {
      libraries?: components['schemas']['LibraryReleaseID'][] | null;
    };
    SketchRemoveLibraryResponse: {
      libraries?: components['schemas']['LibraryReleaseID'][] | null;
    };
    /**
     * @description Application status
     * @enum {string}
     */
    Status: 'starting' | 'running' | 'stopping' | 'stopped' | 'failed';
    UpdateCheckResult: {
      updates?: components['schemas']['UpgradablePackage'][] | null;
    };
    UpgradablePackage: {
      from_version?: string;
      name?: string;
      to_version?: string;
      type?: components['schemas']['PackageType'];
    };
    VersionResponse: {
      version?: string;
    };
  };
  responses: {
    /** @description Bad Request */
    BadRequest: {
      content: {
        'application/json': components['schemas']['ErrorResponse'];
      };
    };
    /** @description Conflict */
    Conflict: {
      content: {
        'application/json': components['schemas']['ErrorResponse'];
      };
    };
    /** @description Internal Server Error */
    InternalServerError: {
      content: {
        'application/json': components['schemas']['ErrorResponse'];
      };
    };
    /** @description No Content */
    NoContent: {
      content: {
        'application/json': components['schemas']['ErrorResponse'];
      };
    };
    /** @description Not Found */
    NotFound: {
      content: {
        'application/json': components['schemas']['ErrorResponse'];
      };
    };
    /** @description Precondition Failed */
    PreconditionFailed: {
      content: {
        'application/json': components['schemas']['ErrorResponse'];
      };
    };
  };
  parameters: never;
  requestBodies: never;
  headers: never;
  pathItems: never;
}

export type $defs = Record<string, never>;

export type external = Record<string, never>;

export interface operations {
  /**
   * Get a list of installed apps/examples
   * @description Returns a list of all apps, and example present. It is also possible to apply different filters.
   */
  getApps: {
    parameters: {
      query?: {
        /** @description Filters apps by apps,examples,default */
        filter?: string;
        /** @description Filters applications by status */
        status?: components['schemas']['Status'];
      };
    };
    responses: {
      /** @description Successful response */
      200: {
        content: {
          'application/json': components['schemas']['AppListResponse'];
        };
      };
      500: components['responses']['InternalServerError'];
    };
  };
  /**
   * Creates a new app
   * @description Creates a new app in the default app location.
   */
  createApp: {
    parameters: {
      query?: {
        /** @description If true, the app will not be created with the sketch part. */
        'skip-sketch'?: boolean;
      };
    };
    requestBody?: {
      content: {
        'application/json': components['schemas']['CreateAppRequest'];
      };
    };
    responses: {
      /** @description Successful response */
      201: {
        content: {
          'application/json': components['schemas']['CreateAppResponse'];
        };
      };
      400: components['responses']['BadRequest'];
      409: components['responses']['Conflict'];
      500: components['responses']['InternalServerError'];
    };
  };
  /**
   * Get brick instances for an app
   * @description Get the list of brick instances for a specific app.
   */
  getAppBrickInstances: {
    parameters: {
      path: {
        /** @description application identifier. */
        appID: string;
      };
    };
    responses: {
      /** @description Successful response */
      200: {
        content: {
          'application/json': components['schemas']['AppBrickInstancesResult'];
        };
      };
      412: components['responses']['PreconditionFailed'];
      500: components['responses']['InternalServerError'];
    };
  };
  /**
   * Get a specific brick instance by ID
   * @description Get a specific brick instance for an app by its ID.
   */
  getAppBrickInstanceByBrickID: {
    parameters: {
      path: {
        /** @description application identifier. */
        appID: string;
        /** @description brick identifier. */
        brickID: string;
      };
    };
    responses: {
      /** @description Successful response */
      200: {
        content: {
          'application/json': components['schemas']['BrickInstance'];
        };
      };
      400: components['responses']['BadRequest'];
      412: components['responses']['PreconditionFailed'];
      500: components['responses']['InternalServerError'];
    };
  };
  /**
   * Upsert a brick instance for an app
   * @description Upsert a brick instance for an app. If the instance does not exist, it will be created. If it exists, it will be updated.
   */
  upsertAppBrickInstance: {
    parameters: {
      path: {
        /** @description application identifier. */
        appID: string;
        /** @description brick identifier. */
        brickID: string;
      };
    };
    requestBody?: {
      content: {
        'application/json': components['schemas']['BrickCreateUpdateRequest'];
      };
    };
    responses: {
      /** @description Successful response */
      200: {
        content: never;
      };
      400: components['responses']['BadRequest'];
      412: components['responses']['PreconditionFailed'];
      500: components['responses']['InternalServerError'];
    };
  };
  /**
   * Delete a brick instance for an app
   * @description Delete a brick instance for an app. It will remove the brick instance from the app.
   */
  deleteAppBrickInstance: {
    parameters: {
      path: {
        /** @description application identifier. */
        appID: string;
        /** @description brick identifier. */
        brickID: string;
      };
    };
    responses: {
      /** @description Successful response */
      200: {
        content: never;
      };
      400: components['responses']['BadRequest'];
      412: components['responses']['PreconditionFailed'];
      500: components['responses']['InternalServerError'];
    };
  };
  /**
   * Update a brick instance for an app
   * @description Update a brick instance for an app. It update/add only the provided fields.
   */
  updateAppBrickInstance: {
    parameters: {
      path: {
        /** @description application identifier. */
        appID: string;
        /** @description brick identifier. */
        brickID: string;
      };
    };
    requestBody?: {
      content: {
        'application/json': components['schemas']['BrickCreateUpdateRequest'];
      };
    };
    responses: {
      /** @description Successful response */
      200: {
        content: never;
      };
      400: components['responses']['BadRequest'];
      412: components['responses']['PreconditionFailed'];
      500: components['responses']['InternalServerError'];
    };
  };
  /**
   * Get app exposed ports
   * @description Return all ports exposed by the given app.
   */
  getAppPorts: {
    parameters: {
      path: {
        /** @description application identifier. */
        appID: string;
      };
    };
    responses: {
      /** @description Successful response */
      200: {
        content: {
          'application/json': components['schemas']['AppPortResponse'];
        };
      };
      412: components['responses']['PreconditionFailed'];
      500: components['responses']['InternalServerError'];
    };
  };
  /**
   * Lists the libraries used in the App' sketch.
   * @description Lists the libraries used in the App' sketch.
   */
  appSketchListLibraries: {
    parameters: {
      path: {
        /** @description application identifier. */
        appID: string;
      };
    };
    responses: {
      /** @description Successful response */
      200: {
        content: {
          'application/json': components['schemas']['SketchListLibraryResponse'];
        };
      };
      400: components['responses']['BadRequest'];
      412: components['responses']['PreconditionFailed'];
      500: components['responses']['InternalServerError'];
    };
  };
  /**
   * Adds a library to the App' sketch.
   * @description Adds a library to the App' sketch. The library will be added to the sketch project file. The dependencies of the library may be optionally added as well.
   */
  appSketchAddLibrary: {
    parameters: {
      query?: {
        /** @description if set to "true", the library's dependencies will be added as well. */
        add_deps?: string;
      };
      path: {
        /** @description application identifier. */
        appID: string;
        /** @description library reference ("LibraryName" or "LibraryName@Version"). */
        libRef: string;
      };
    };
    responses: {
      /** @description Successful response */
      200: {
        content: {
          'application/json': components['schemas']['SketchAddLibraryResponse'];
        };
      };
      400: components['responses']['BadRequest'];
      412: components['responses']['PreconditionFailed'];
      500: components['responses']['InternalServerError'];
    };
  };
  /**
   * Removes a library from the App' sketch.
   * @description Removes a library from the App' sketch. The library will be removed from the sketch project file.
   */
  appSketchRemoveLibrary: {
    parameters: {
      path: {
        /** @description application identifier. */
        appID: string;
        /** @description library reference ("LibraryName" or "LibraryName@Version"). */
        libRef: string;
      };
    };
    responses: {
      /** @description Successful response */
      200: {
        content: {
          'application/json': components['schemas']['SketchRemoveLibraryResponse'];
        };
      };
      400: components['responses']['BadRequest'];
      412: components['responses']['PreconditionFailed'];
      500: components['responses']['InternalServerError'];
    };
  };
  /**
   * Get app/example detail
   * @description Return all the detail for the given app
   */
  getAppDetails: {
    parameters: {
      path: {
        /** @description application identifier. */
        id: string;
      };
    };
    responses: {
      /** @description Successful response */
      200: {
        content: {
          'application/json': components['schemas']['AppDetailedInfo'];
        };
      };
      412: components['responses']['PreconditionFailed'];
      500: components['responses']['InternalServerError'];
    };
  };
  /**
   * delete the app
   * @description Remove the given app and all the resources it created
   */
  deleteApp: {
    parameters: {
      path: {
        /** @description application identifier. */
        id: string;
      };
    };
    responses: {
      /** @description Successful response */
      200: {
        content: never;
      };
      400: components['responses']['BadRequest'];
      412: components['responses']['PreconditionFailed'];
      500: components['responses']['InternalServerError'];
    };
  };
  /**
   * Update App Details
   * @description Edit the given application. Is it possible to modify the default status, to add/remove/update bricks and bricks variables.
   */
  editApp: {
    parameters: {
      path: {
        /** @description application identifier. */
        id: string;
      };
    };
    requestBody?: {
      content: {
        'application/json': components['schemas']['EditRequest'];
      };
    };
    responses: {
      /** @description Successful response */
      200: {
        content: {
          'application/json': components['schemas']['AppDetailedInfo'];
        };
      };
      400: components['responses']['BadRequest'];
      412: components['responses']['PreconditionFailed'];
      500: components['responses']['InternalServerError'];
    };
  };
  /**
   * Creates a new app, from another app or example identified by ID.
   * @description Clone an existing app or example, in a new one. It is possible to specify the new name and icon.
   */
  cloneApp: {
    parameters: {
      path: {
        /** @description application identifier. */
        id: string;
      };
    };
    requestBody?: {
      content: {
        'application/json': components['schemas']['CloneRequest'];
      };
    };
    responses: {
      /** @description Successful response */
      201: {
        content: {
          'application/json': components['schemas']['CloneAppResponse'];
        };
      };
      400: components['responses']['BadRequest'];
      404: components['responses']['NotFound'];
      409: components['responses']['Conflict'];
      412: components['responses']['PreconditionFailed'];
      500: components['responses']['InternalServerError'];
    };
  };
  /**
   * Get application events
   * @description Returns events for a specific app
   */
  getAppEvents: {
    parameters: {
      path: {
        /** @description application identifier. */
        id: string;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          'text/event-stream': string;
        };
      };
      500: components['responses']['InternalServerError'];
    };
  };
  /**
   * Get the logs of a running app
   * @description Obtain a ServerSentEvnt stream of logs. It is possible to apply different filters.
   */
  getAppLogs: {
    parameters: {
      query?: {
        filter?: string;
        tail?: number;
        nofollow?: boolean;
      };
      path: {
        /** @description application identifier. */
        id: string;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          'text/event-stream': string;
        };
      };
      400: components['responses']['BadRequest'];
      412: components['responses']['PreconditionFailed'];
      500: components['responses']['InternalServerError'];
    };
  };
  /**
   * Start an existing app/example
   * @description Start the application and handles all the operation to start any dependecies. If the app contains a sketch it also flash it in the micro.
   */
  startApp: {
    parameters: {
      path: {
        /** @description application identifier. */
        id: string;
      };
    };
    responses: {
      /**
       * @description A stream of Server-Sent Events (SSE) that notifies the progress.
       * The client will receive events formatted as follows:
       *
       * **Event 'progress'**:
       * Contains a JSON object with the percentage of completion.
       * 'event: progress'
       * 'data: {"progress":0.25}'
       *
       * **Event 'message'**:
       * Contains a JSON object with an informational message.
       * 'event: message'
       * 'data: {"message":"Starting container..."}'
       *
       * **Event 'error'**:
       * Contains a JSON object with the details of an error.
       * 'event: error'
       * 'data: {"code":"INTERNAL_SERVER_ERROR","message":"An error occurred during operation"}'
       */
      200: {
        content: {
          'text/event-stream': string;
        };
      };
      412: components['responses']['PreconditionFailed'];
      500: components['responses']['InternalServerError'];
    };
  };
  /**
   * Stop an existing app/example
   * @description Stop the application and all it's dependecies. If the app contains a sketch it also remove it from the micro.
   */
  stopApp: {
    parameters: {
      path: {
        /** @description application identifier. */
        id: string;
      };
    };
    responses: {
      /**
       * @description A stream of Server-Sent Events (SSE) that notifies the progress.
       * The client will receive events formatted as follows:
       *
       * **Event 'progress'**:
       * Contains a JSON object with the percentage of completion.
       * 'event: progress'
       * 'data: {"progress":0.25}'
       *
       * **Event 'message'**:
       * Contains a JSON object with an informational message.
       * 'event: message'
       * 'data: {"message":"Stopping container..."}'
       *
       * **Event 'error'**:
       * Contains a JSON object with the details of an error.
       * 'event: error'
       * 'data: {"code":"INTERNAL_SERVER_ERROR","message":"An error occurred during operation"}'
       */
      200: {
        content: {
          'text/event-stream': string;
        };
      };
      412: components['responses']['PreconditionFailed'];
      500: components['responses']['InternalServerError'];
    };
  };
  /**
   * Get application events
   * @description A stream of Server-Sent Events (SSE) that notifies the apps status.
   * The client will receive events formatted as follows:
   *
   * **Event 'app'**:
   * Contains a JSON object with an informational message.
   * 'event: app'
   * 'data: {"id":"dXNlcjpleGFtcG","name":"example-app-for-status-events","description":"My app description","icon":"ðŸ’»","status":"running","example":false,"default":false}'
   *
   * **Event 'error'**:
   * Contains a JSON object with the details of an error.
   * 'event: error'
   * 'data: {"code":"INTERNAL_SERVER_ERROR","message":"An error occurred during operation"}'
   */
  getAppsEvents: {
    responses: {
      /** @description OK */
      200: {
        content: {
          'text/event-stream': string;
        };
      };
      500: components['responses']['InternalServerError'];
    };
  };
  /**
   * Get a list of available bricks
   * @description Returns all the existing bricks. Bricks that are ready to use are marked as installed.
   */
  getBricks: {
    responses: {
      /** @description Successful response */
      200: {
        content: {
          'application/json': components['schemas']['BrickListResult'];
        };
      };
      500: components['responses']['InternalServerError'];
    };
  };
  /**
   * Detail of a brick
   * @description Returns a detailed list of property associated to the given brick.
   */
  getBrickDetails: {
    parameters: {
      path: {
        /** @description brick identifier. */
        id: string;
      };
    };
    responses: {
      /** @description Successful response */
      200: {
        content: {
          'application/json': components['schemas']['BrickDetailsResult'];
        };
      };
      400: components['responses']['BadRequest'];
      404: components['responses']['NotFound'];
      500: components['responses']['InternalServerError'];
    };
  };
  /**
   * returns application configuration
   * @description returns information about current directory configuration used by the app
   */
  getConfig: {
    responses: {
      /** @description Successful response */
      200: {
        content: {
          'application/json': components['schemas']['ConfigResponse'];
        };
      };
      500: components['responses']['InternalServerError'];
    };
  };
  /**
   * Search Arduino libraries
   * @description Search for Arduino libraries in the registry with various filters.
   */
  listLibraries: {
    parameters: {
      query?: {
        /** @description Search term to filter libraries by name, sentence, paragraph. */
        search?: string;
        /** @description Filter libraries by target architecture */
        architecture?: string;
        /** @description Filter libraries by platform */
        platform?: string;
        /** @description Sort order for the results */
        sort?:
          | 'stars_asc'
          | 'stars_desc'
          | 'forks_asc'
          | 'forks_desc'
          | 'recent_asc'
          | 'recent_desc';
        /** @description Page number for pagination */
        page?: number;
        /** @description Number of results per page */
        limit?: number;
      };
    };
    responses: {
      /** @description Successful response with library search results */
      200: {
        content: {
          'application/json': components['schemas']['LibraryListResponse'];
        };
      };
      400: components['responses']['BadRequest'];
      500: components['responses']['InternalServerError'];
    };
  };
  /**
   * Get a list of available AI models
   * @description Returns the list of AI models available in the system. It is possible to filter the models by bricks.
   */
  getAIModels: {
    parameters: {
      query?: {
        /** @description Filter models by bricks. If not specified, all models are returned. */
        bricks?: string;
      };
    };
    responses: {
      /** @description Successful response */
      200: {
        content: {
          'application/json': components['schemas']['AIModelsListResult'];
        };
      };
      500: components['responses']['InternalServerError'];
    };
  };
  /**
   * Get AI model details
   * @description Returns the details of a specific AI model.
   */
  getAIModelDetails: {
    parameters: {
      path: {
        /** @description AI model identifier. */
        id: string;
      };
    };
    responses: {
      /** @description Successful response */
      200: {
        content: {
          'application/json': components['schemas']['AIModelItem'];
        };
      };
      500: components['responses']['InternalServerError'];
    };
  };
  /**
   * Get system properties
   * @description Return the list of system properties.
   */
  GetPropertyKeys: {
    responses: {
      /** @description Successful response */
      200: {
        content: {
          'application/json': components['schemas']['PropertyKeysResponse'];
        };
      };
      500: components['responses']['InternalServerError'];
    };
  };
  /**
   * Get property by key
   * @description Return a single property by the provided key.
   */
  GetProperty: {
    parameters: {
      path: {
        /** @description property key. */
        key: string;
      };
    };
    responses: {
      /** @description Successful response */
      200: {
        content: {
          'application/octet-stream': string;
        };
      };
      400: components['responses']['BadRequest'];
      404: components['responses']['NotFound'];
      500: components['responses']['InternalServerError'];
    };
  };
  /**
   * Upsert property
   * @description Update or create a new property.
   */
  UpdateProperty: {
    parameters: {
      path: {
        /** @description property key. */
        key: string;
      };
    };
    requestBody?: {
      content: {
        'application/json': string;
      };
    };
    responses: {
      /** @description Successful response */
      200: {
        content: {
          'application/octet-stream': string;
        };
      };
      400: components['responses']['BadRequest'];
      404: components['responses']['NotFound'];
      500: components['responses']['InternalServerError'];
    };
  };
  /**
   * Delete property by key
   * @description Delete the property by the provided key.
   */
  DeleteProperty: {
    parameters: {
      path: {
        /** @description property key. */
        key: string;
      };
    };
    responses: {
      /** @description Successful response */
      204: {
        content: {
          'application/json': string;
        };
      };
      400: components['responses']['BadRequest'];
      404: components['responses']['NotFound'];
      500: components['responses']['InternalServerError'];
    };
  };
  /**
   * Get system resources usage
   * @description Returns the system resources usage, such as memory, disk and CPU.
   */
  getSystemResources: {
    responses: {
      /**
       * @description A stream of Server-Sent Events (SSE) that notifies the stats.
       * The client will receive events formatted as follows:
       *
       * **Event 'cpu'**:
       * Contains a JSON object with the CPU information.
       * 'event: stats'
       * 'data: {"used_percent": 0.25}'
       *
       * **Event 'mem'**:
       * Contains a JSON object with the memory information.
       * 'event: mem'
       * 'data: {"used": 1024, "total": 2048}'
       *
       * **Event 'disk'**:
       * Contains a JSON object with the disk information.
       * 'event: disk'
       * 'data: {"path":"/", "used": 512, "total": 1024}'
       *
       * **Event 'error'**:
       * Contains a JSON object with the details of an error.
       * 'event: error'
       * 'data: {"code":"INTERNAL_SERVER_ERROR","message":"An error occurred during operation"}'
       */
      200: {
        content: {
          'text/event-stream': string;
        };
      };
      500: components['responses']['InternalServerError'];
    };
  };
  /**
   * Start the upgrade process in background
   * @description Start the upgrade process.
   */
  applyUpdate: {
    parameters: {
      query?: {
        /** @description If true, upgrade only the Arduino packages that require an upgrade. Default is false. */
        'only-arduino'?: boolean;
      };
    };
    responses: {
      /** @description Successful response */
      200: {
        content: never;
      };
      204: components['responses']['NoContent'];
      409: components['responses']['Conflict'];
      500: components['responses']['InternalServerError'];
    };
  };
  /**
   * Get the packages that requires an upgrade
   * @description Returns the details of packages to be upgraded.
   */
  checkUpdate: {
    parameters: {
      query?: {
        /** @description If true, check only for Arduino packages that require an upgrade. Default is false. */
        'only-arduino'?: boolean;
      };
    };
    responses: {
      /** @description Successful response */
      200: {
        content: {
          'application/json': components['schemas']['UpdateCheckResult'];
        };
      };
      204: components['responses']['NoContent'];
      400: components['responses']['BadRequest'];
      500: components['responses']['InternalServerError'];
    };
  };
  /**
   * SSE stream of the update process
   * @description Returns the events of current update process.
   */
  eventsUpdate: {
    responses: {
      /**
       * @description A stream of Server-Sent Events (SSE) that notifies the progress of the update process.
       * The client will receive events formatted as follows:
       *
       * **Event 'log'**:
       * Contains a log message of the apt upgrade command.
       * 'event: log'
       * 'data: "updating package: 0.25"'
       *
       * **Event 'restarting'**:
       * Contains a string with the message that the upgrade is completed and the system is restarting.
       * 'event: restarting'
       * 'data: Upgrade completed. Restarting'
       *
       * **Event 'error'**:
       * Contains a JSON object with the details of an error.
       * 'event: error'
       * 'data: {"code":"internal_service_err","message":"An error occurred during operation"}'
       */
      200: {
        content: {
          'text/event-stream': string;
        };
      };
      500: components['responses']['InternalServerError'];
    };
  };
  /**
   * application version
   * @description returns the application current version
   */
  getVersions: {
    responses: {
      /** @description Successful response */
      200: {
        content: {
          'application/json': components['schemas']['VersionResponse'];
        };
      };
      500: components['responses']['InternalServerError'];
    };
  };
}
